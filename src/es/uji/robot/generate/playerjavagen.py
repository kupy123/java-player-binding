#!/usr/bin/env python

#Copyright (C) 2009  Leo Nomdedeu, David Olmos
#
#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#any later version.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
######################################################################
#
# Authors: Leo Nomdedeu, David Olmos
# Release: 0.1pre_alfa
# Changelog:
#        0.1pre_alfa: Initial release
######################################################################

import re
import string
import sys
import os

VALUE_PATH = 'es/uji/robot/player/generated/value/'
XDR_PATH = 'es/uji/robot/player/generated/xdr/'

USAGE = 'USAGE: playerjavagen.y [-distro] <interface-spec.h> [<extra_interface-spec.h>] \n <-D> <destination directory>'

command = ""
for i in xrange(len(sys.argv)):
    command += sys.argv[i] + " "

LICENSE = "/**\n* Copyright (C) 2009  Leo Nomdedeu, David Olmos\n*\n* ### Autogenerated file with command \n* " + command + "\n* Do not make changes to this file.\n*\n* This program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation, either version 3 of the License, or\n* any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*\n*********************************************************************\n*\n* Authors: Leo Nomdedeu, David Olmos\n* Release: 0.1pre_alfa\n* Changelog:\n*\t\t0.1pre_alfa: Initial release\n*********************************************************************\n*/\n\n"

# Test if argument -D has been passed
dir = False
DIR = " "

for i in xrange(len(sys.argv)):
    if sys.argv[i] == "-D":
        dir = True
        if len(sys.argv) < i+2:
            print "Not a suitable directory gave"
            sys.exit(-1)
        else:
            if os.path.exists(sys.argv[i+1]):
                if sys.argv[i+1][-1] != "/":
                    DIR = sys.argv[i+1] + "/"
                else:
                    DIR = sys.argv[i+1]
            else:
                print "Directory does not exist"
                sys.exit(-1)
                
                
# Test if the directories are created before generating the new files
# If the directory exists and is not empty, delete the content
if dir:
    if not os.path.isdir(DIR + VALUE_PATH):
        os.makedirs(DIR + VALUE_PATH)
    else:
        for fileInDir in os.listdir(DIR + VALUE_PATH):
            filePath = os.path.join(DIR + VALUE_PATH, fileInDir)
            try:
                if os.path.isfile(filePath):
                    os.unlink(filePath)
            except Exception, e:
                print e
    if not os.path.isdir(DIR + XDR_PATH):
        os.makedirs(DIR + XDR_PATH)
    else:
        for fileInDir in os.listdir(DIR + XDR_PATH):
            filePath = os.path.join(DIR + XDR_PATH, fileInDir)
            try:
                if os.path.isfile(filePath):
                    os.unlink(filePath)
            except Exception, e:
                print e
else:
    if not os.path.isdir("./" + VALUE_PATH):
        os.makedirs("./" + VALUE_PATH)
    else:
        for fileInDir in os.listdir("./" + VALUE_PATH):
            filePath = os.path.join("./" + VALUE_PATH, fileInDir)
            try:
                if os.path.isfile(filePath):
                    os.unlink(filePath)
            except Exception, e:
                print e
    if not os.path.isdir("./" + XDR_PATH):
        os.makedirs("./" + XDR_PATH)
    else:
        for fileInDir in os.listdir("./" + XDR_PATH):
            filePath = os.path.join("./" + XDR_PATH, fileInDir)
            try:
                if os.path.isfile(filePath):
                    os.unlink(filePath)
            except Exception, e:
                print e



hasdynamic = []
# Array to store all the strings, so then we know if we are using a string or not
strings = []

class DataTypeMember:
    arraypattern = re.compile('\[(.*?)\]')
    pointerpattern = re.compile('\*')
    
    def __init__(self, body):
        # is it an array or a scalar?
        self.array = False
        self.pointer = False
        self.arraysize = self.arraypattern.findall(body)
        pointers = self.pointerpattern.findall(body)
        if len(self.arraysize) > 0:
            self.array = True
            self.arraysize = self.arraysize[0]
            body = self.arraypattern.sub('', body)
            
        elif len(pointers) > 1:  # This checks for things like "uint8_t* *data"
            raise 'Illegal pointer declaration in struct\n' + body
        elif len(pointers) > 0:
            self.array = True
            self.arraysize = ''
            self.pointer = True
            body = self.pointerpattern.sub('', body)

        self.Name = body.strip()
        self.pointervar = self.Name + '_p'
        self.countvar = self.Name + '_count'
  
# multiple variables can occur with single type, i.e. int a,b,c so we first get the type and then add each variable to the entry
class DataTypeMemberSet:
      typepattern = re.compile('\s*\w+')
      variablepattern = re.compile('\s*([^,;]+?)\s*[,;]')
      
      def __init__(self, body):
        self.haspointer = False
        self.hasarray = False
        self.variables = []
        self.typename = self.typepattern.findall(body)[0].strip()
        if self.typename in hasdynamic:
            self.dynamic = True
        else:
            self.dynamic = False
        
        # find the variable names
        body = self.typepattern.sub('', body, 1)
        vars = self.variablepattern.findall(body)
        
        
        # iterate through each variable
        for varstring in vars:
            member = DataTypeMember(varstring)
            self.variables.append(member)
            if member.pointer:
                self.haspointer = True
            if member.array:
                self.hasarray = True
          

class DataType:
    contentspattern = re.compile('.*\{\s*(.*?)\s*\}', re.MULTILINE | re.DOTALL)
    declpattern = re.compile('\s*([^;]*?;)', re.MULTILINE)
  
    def __init__(self, body):
        split = string.split(body)
        self.prefix = split[2]
        self.typename = split[-1]
        self.dynamic = False
        self.hasarray = False
        self.haspointer = False

        self.members = []
        # pick out the contents of the struct
        varpart = self.contentspattern.findall(body)
        if len(varpart) != 1:
            print 'skipping nested / empty struct ' + typename
            raise "Empty Struct"
        # separate the variable declarations
        decls = self.declpattern.findall(varpart[0])
        for dstring in decls:
              ms = DataTypeMemberSet(dstring)
              self.members.append(ms)
              if ms.haspointer or ms.dynamic:
                  self.dynamic = True
              if ms.hasarray:
                  self.hasarray = True
              if ms.haspointer:
                  self.haspointer = True
          
        if self.dynamic:
            hasdynamic.append (self.typename)
            
    def GetVarNames(self):
        varnames = []
        for m in self.members:
          for v in m.variables:
            varnames.append(v.Name)
        return varnames
    
    def HasDynamicArray(self):
        for m in self.members:
            if m.dynamic:
                for v in m.variables:
                    if v.array:
                        return True
        return False
	

class MethodGenerator:
      def __init__(self,sourcefile):
          self.sourcefile = sourcefile
          self.code = ""
          
       # Heading used for the xdr files   
      def genHeadings(self, datatype):
          self.hasArray = False
          self.hasBaos = False
          self.code = ""
          self.code +="package es.uji.robot.player.generated.xdr;\n"
          self.code +="\n"
          self.code +="import java.io.IOException;\n"
          self.code += "ARRAYLIST" # Tag used to make the import of ArrayList if needed
          self.code += "BAOS" # Tag used to make the import of ByteArrayOutputStream if needed
          self.code +="\n"
          self.code +="import es.uji.robot.xdr.*;\n"
          self.code +="import es.uji.robot.player.generated.value."+goodName(datatype.prefix)+"Value;\n"
          self.code +="public class %s extends %sValue implements XDRObject{\n" % (goodName(datatype.prefix), goodName(datatype.prefix))
          
          self.code +="    private static final long serialVersionUID = " + serial + "L;\n\n"
          
          return (self.code,self.hasArray, self.hasBaos)
        
      # Headings for the value objects
      def genJava(self,datatype, sourcefilename):
          self.hasArray = False
          self.hasBaos = False
          self.code = ""
          self.code +="package es.uji.robot.player.generated.value;\n"
          self.code +="\n"
          self.code +="import java.io.Serializable;\n"
          self.code += "ARRAYLIST" # Tag used to make the import of ArrayList if needed
          self.code += "BAOS" # Tag used to make the import of ByteArrayOutputStream if needed
          self.code +="\n"
          self.code +="public class %sValue implements Serializable{\n" % (goodName(datatype.prefix))
          
          self.code +="    private static final long serialVersionUID = " + serial + "L;\n\n"
          
          for member in datatype.members:			
              for var in member.variables:
                  primitive = True #Primitive java types
                  # Do some name mangling for common types
                  
                  # Special management for some variable names
                  if var.Name == "name" and member.typename.find("int8") >= 0:
                      member.typename = 'char'
                  if var.Name == "data" and member.typename.find("char") >= 0:
                      member.typename = 'uint8_t'
                      
                  if member.typename == 'long long':
                      typename = 'long'
                  elif member.typename == 'int64_t':
                      typename = 'long'
                  elif member.typename == 'uint64_t':
    				  typename = 'long'
                  elif member.typename == 'int32_t':
    				  typename = 'int'
                  elif member.typename == 'uint32_t':
    				  typename = 'int'
                  elif member.typename == 'int16_t':
                      typename = 'short'
                  elif member.typename == 'uint16_t':
                      typename = 'short'
                  elif member.typename == 'char':
                      typename = 'char'
                  elif member.typename == 'int8_t':
                      typename = 'byte'
                  elif member.typename == 'uint8_t':
                      #typename = 'char'
                      typename = 'byte'
                  elif member.typename == 'bool_t':
                      typename = 'boolean'
                  elif member.typename == 'double':
                      typename = 'double'
                  elif member.typename == 'int':
                      typename = 'int'
                  elif member.typename == 'float':
                      typename = 'float'
                  elif member.typename == 'long':
                      typename = 'long'
                  elif member.typename == 'boolean':
                      typename = 'boolean'
                  elif member.typename == 'short':
                      typename = 'short'
                  else:
    			 	  # rely on a previous declaration of an xdr_ proc for this type
    				  typename = member.typename
    				  primitive = False
                      
                  first = typename[0]
                  if var.array:
                      if primitive:
                          if typename == 'char':
                              self.hasBaos = True
                              #self.code +="	private ByteArrayOutputStream %s = new ByteArrayOutputStream();\n" % (goodNameVar(var.Name))
                              self.code +="    private String %s = new String();\n" % (goodNameVar(var.Name))
                              strings.append(goodNameVar(var.Name))
                          elif typename == 'byte':
                              self.code +="    private ByteArrayOutputStream %s = new ByteArrayOutputStream();\n" % (goodNameVar(var.Name))
                          elif typename == 'int':
                              self.hasArray = True
                              self.code +="	private List<%s> %s = new ArrayList<%s>();\n" % ("Integer", goodNameVar(var.Name), "Integer")
                          else:
                              self.hasArray = True
                              self.code +="	private List<%s> %s = new ArrayList<%s>();\n" % (first.upper()+typename[1:], goodNameVar(var.Name), first.upper()+typename[1:])
                      else:
                          self.hasArray = True
                          self.code +="	private List<? extends %sValue> %s = new ArrayList<%sValue>();\n" % (goodName(typename[:-2]), goodNameVar(var.Name), goodName(typename[:-2]))
                  else:
                      # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                      # also we test if the file is not in the array of diffFiles (files that are treated different)
                      if "count" not in var.Name or sourcefilename in diffFiles:
                          if primitive:
                              if member.typename == "uint8_t":
                                  typename = 'char'
                              self.code +="	private %s %s;\n" % (typename,goodNameVar(var.Name))
                          else:
                              self.code +="	private %sValue %s;\n" % (goodName(typename[:-2]),goodNameVar(var.Name))
          self.code +="\n"
          return (self.code,self.hasArray, self.hasBaos)
    	
      
      def genConstructorWithParameters(self,datatype, sourcefilename):
          self.hasArray = False
          self.hasBaos = False
          self.code = ""
          
          self.code +="	public %s(byte[] buffer, int idx, int len) throws XDRException{\n" % (goodName(datatype.prefix))
          self.code +="		this.fromXDR(buffer, idx, len);\n"
          self.code +="	}\n"
          return (self.code,self.hasArray, self.hasBaos)
          
      def genConstructorCopy(self, datatype, sourcefilename):
          self.hasArray = False
          self.hasBaos = False
          self.code = ""
          
          self.code +="    public %sValue(%sValue src) {\n" % (goodName(datatype.prefix), goodName(datatype.prefix))
          
          for member in datatype.members:
              for var in member.variables:
                  # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                  # also we test if the file is not in the array of diffFiles (files that are treated different)
                  if "count" not in var.Name or sourcefilename in diffFiles:
                      self.code +="        this.%s = src.%s;\n" % (goodNameVar(var.Name), goodNameVar(var.Name))
                      
          self.code +="    }\n"
          return (self.code,self.hasArray, self.hasBaos)
          
      def genXDRConstructor(self, datatype, sourcefilename):
          self.hasArray = False
          self.hasBaos = False
          self.code = ""
          
          self.code +="    public %s(){\n" % (goodName(datatype.prefix))
          
          for member in datatype.members:            
              for var in member.variables:
                  primitive = True #Primitive java types
                  # Do some name mangling for common types
                  if member.typename == 'long long':
                      typename = 'long'
                  elif member.typename == 'int64_t':
                      typename = 'long'
                  elif member.typename == 'uint64_t':
                      typename = 'long'
                  elif member.typename == 'int32_t':
                      typename = 'int'
                  elif member.typename == 'uint32_t':
                      typename = 'int'
                  elif member.typename == 'int16_t':
                      typename = 'short'
                  elif member.typename == 'uint16_t':
                      typename = 'short'
                  elif member.typename == 'int8_t' or member.typename == 'char':
                      typename = 'char'
                  elif member.typename == 'uint8_t':
                      typename = 'char'
                  elif member.typename == 'bool_t':
                      typename = 'boolean'
                  elif member.typename == 'double':
                      typename = 'double'
                  elif member.typename == 'int':
                      typename = 'int'
                  elif member.typename == 'float':
                      typename = 'float'
                  elif member.typename == 'long':
                      typename = 'long'
                  elif member.typename == 'boolean':
                      typename = 'boolean'
                  elif member.typename == 'short':
                      typename = 'short'
                  else:
                      # rely on a previous declaration of an xdr_ proc for this type
                      typename = member.typename
                      primitive = False
                      
                  if not var.array:
                      # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                      # also we test if the file is not in the array of diffFiles (files that are treated different)
                      if "count" not in var.Name  or sourcefilename in diffFiles:
                          if typename == 'int':
                              self.code +="        %s(0);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          elif typename == 'float':
                              self.code +="        %s((float)0.0);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          elif typename == 'long':
                              self.code +="        %s(0l);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          elif typename == 'double':
                              self.code +="        %s(0.0);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          elif typename == 'short':
                              self.code +="        %s((short)0);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          elif typename == 'boolean':
                              self.code +="        %s(true);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          elif typename == 'byte':
                              self.code +="        %s(byte)0);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          elif typename == 'char':
                              self.code +="        %s('c');\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                                        
          self.code +="    }\n"
          return (self.code,self.hasArray, self.hasBaos)
              
      def genConstructor(self,datatype, sourcefilename):
          self.hasArray = False
          self.hasBaos = False
          self.code = ""
          
          self.code +="    public %sValue(){\n" % (goodName(datatype.prefix))
          
          for member in datatype.members:			
              for var in member.variables:
                  primitive = True #Primitive java types
                  # Do some name mangling for common types
                  if member.typename == 'long long':
                      typename = 'long'
                  elif member.typename == 'int64_t':
                      typename = 'long'
                  elif member.typename == 'uint64_t':
    				  typename = 'long'
                  elif member.typename == 'int32_t':
    				  typename = 'int'
                  elif member.typename == 'uint32_t':
    				  typename = 'int'
                  elif member.typename == 'int16_t':
    				  typename = 'short'
                  elif member.typename == 'uint16_t':
    				  typename = 'short'
                  elif member.typename == 'int8_t' or member.typename == 'char':
    				  typename = 'char'
                  elif member.typename == 'uint8_t':
    				  typename = 'char'
                  elif member.typename == 'bool_t':
    				  typename = 'boolean'
                  elif member.typename == 'double':
                      typename = 'double'
                  elif member.typename == 'int':
                      typename = 'int'
                  elif member.typename == 'float':
                      typename = 'float'
                  elif member.typename == 'long':
                      typename = 'long'
                  elif member.typename == 'boolean':
                      typename = 'boolean'
                  elif member.typename == 'short':
                      typename = 'short'
                  else:
                      # rely on a previous declaration of an xdr_ proc for this type
                      typename = member.typename
                      primitive = False
                      
                  if not var.array:
                      # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                      # also we test if the file is not in the array of diffFiles (files that are treated different)
                      if "count" not in var.Name  or sourcefilename in diffFiles:
                          if typename == 'int':
                              self.code +="        this.%s = 0;\n" % (goodNameVar(var.Name))
                          elif typename == 'float':
                              self.code +="        this.%s = (float)0.0;\n" % (goodNameVar(var.Name))
                          elif typename == 'long':
                              self.code +="        this.%s = 0l;\n" % (goodNameVar(var.Name))
                          elif typename == 'double':
                              self.code +="        this.%s = 0.0;\n" % (goodNameVar(var.Name))
                          elif typename == 'short':
                              self.code +="        this.%s = (short)0;\n" % (goodNameVar(var.Name))
                          elif typename == 'boolean':
                              self.code +="        this.%s = true;\n" % (goodNameVar(var.Name))
                          elif typename == 'byte':
                              self.code +="        this.%s = (byte)0;\n" % (goodNameVar(var.Name))
                          elif typename == 'char':
                              self.code +="        this.%s = 'c';\n" % (goodNameVar(var.Name))
                                        
          self.code +="    }\n"
          return (self.code,self.hasArray, self.hasBaos)
    	
      def genSetterGetter(self,datatype, sourcefilename):
          self.hasArray = False
          self.hasBaos = False
          self.code = ""
          
          for member in datatype.members:
              for var in member.variables:
                  primitive = True #Primitive java types
                  # Do some name mangling for common types
                  
                  # Special management for some variable names
                  if var.Name == "name" and member.typename.find("int8") >= 0:
                      member.typename = 'char'
                  if var.Name == "data" and member.typename.find("char") >= 0:
                      member.typename = 'uint8_t'
                      
                  if member.typename == 'long long':
                      typename = 'long'
                  elif member.typename == 'int64_t':
                      typename = 'long'
                  elif member.typename == 'uint64_t':
                      typename = 'long'
                  elif member.typename == 'int32_t':
    				  typename = 'int'
                  elif member.typename == 'uint32_t':
    				  typename = 'int'
                  elif member.typename == 'int16_t':
    				  typename = 'short'
                  elif member.typename == 'uint16_t':
    				  typename = 'short'
                  elif member.typename == 'char':
    				  typename = 'char'
                  elif member.typename == 'int8_t':
                      typename = 'byte'    
                  elif member.typename == 'uint8_t':
    				  #typename = 'char'
                      typename = 'byte'
                  elif member.typename == 'bool_t':
    				  typename = 'boolean'
                  elif member.typename == 'double':
    				  typename = 'double'
                  elif member.typename == 'int':
                      typename = 'int'
                  elif member.typename == 'float':
                      typename = 'float'
                  elif member.typename == 'long':
                      typename = 'long'
                  elif member.typename == 'boolean':
                      typename = 'boolean'
                  elif member.typename == 'short':
                      typename = 'short'
                  else:
                      # rely on a previous declaration of an xdr_ proc for this type
    				  typename = member.typename
    				  primitive = False
                
                  first = var.Name[0]
                  firstTypename = typename[0]
                  
                  #First we do the getters
                  # Booleans are treated different, so we treat them first. The method "get" is "is"
                  if member.typename == 'Boolean':
                      if var.array:	
                          if primitive:
                              self.hasArray = True
                              self.code +="	public List<%s> %s(){\n" % (firstTypename.upper()+typename[1:],"is"+first.upper()+goodNameVar(var.Name[1:]))
                          else:
                              self.hasArray = True
                              self.code +="	public List<%sValue> %s(){\n" % (goodName(typename[:-2]),"is"+first.upper()+goodNameVar(var.Name[1:]))					
                      else:
                          if primitive:
                              self.code +="	public %s %s(){\n" % (typename,"is"+first.upper()+goodNameVar(var.Name[1:]))
                          else:
                              self.code +="	public %sValue %s(){\n" % (goodName(typename),"is"+first.upper()+goodNameVar(var.Name[1:-2]))
                  else:
                      if var.array:
                          if typename == 'char':
                              self.hasBaos = True
                              #self.code +="	public ByteArrayOutputStream %s(){\n" % ("get"+first.upper()+goodNameVar(var.Name[1:]))
                              self.code +="    public String %s(){\n" % ("get"+first.upper()+goodNameVar(var.Name[1:]))
                          elif typename == 'byte':
                              self.code +="    public ByteArrayOutputStream %s(){\n" % ("get"+first.upper()+goodNameVar(var.Name[1:]))
                          elif typename == 'int':
                              self.hasArray = True
                              self.code +="	public List<%s> %s(){\n" % ("Integer","get"+first.upper()+goodNameVar(var.Name[1:]))	
                          else:
                              if primitive:
                                  self.hasArray = True
                                  self.code +="	public List<%s> %s(){\n" % (firstTypename.upper()+typename[1:],"get"+first.upper()+goodNameVar(var.Name[1:]))
                              else:
                                  self.hasArray = True
                                  self.code +="	public List<? extends %sValue> %s(){\n" % (goodName(typename[:-2]),"get"+first.upper()+goodNameVar(var.Name[1:]))
                      else:
                          # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                          # also we test if the file is not in the array of diffFiles (files that are treated different)
                          if "count" not in var.Name  or sourcefilename in diffFiles:
                              if primitive:
                                  if member.typename == "uint8_t":
                                      typename = 'char'
                                  self.code +="	public %s %s(){\n" % (typename,"get"+first.upper()+goodNameVar(var.Name[1:]))
                              else:
                                  self.code +="	public %sValue %s(){\n" % (goodName(typename[:-2]),"get"+first.upper()+goodNameVar(var.Name[1:]))
                
                  # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                  # also we test if the file is not in the array of diffFiles (files that are treated different)
                  if "count" not in var.Name  or sourcefilename in diffFiles:
                      self.code +="		return this.%s;\n" % (goodNameVar(var.Name))
                      self.code +="	}\n\n"
                    
                  # Once we have made the getters we generate self.code for the setters  
                  if var.array:
                      if typename == 'char':
                          self.hasBaos = True
                          #self.code +="	public void %s(ByteArrayOutputStream %s){\n" % ("set"+first.upper()+goodNameVar(var.Name[1:]),goodNameVar(var.Name))
                          self.code +="    public void %s(String %s){\n" % ("set"+first.upper()+goodNameVar(var.Name[1:]),goodNameVar(var.Name))
                      elif typename == 'byte':
                          self.hasBaos = True
                          self.code +="    public void %s(ByteArrayOutputStream %s){\n" % ("set"+first.upper()+goodNameVar(var.Name[1:]),goodNameVar(var.Name))
                      elif typename == 'int':
                          self.hasArray = True
                          self.code +="	public void %s(ArrayList<%s> %s){\n" % ("set"+first.upper()+goodNameVar(var.Name[1:]),"Integer",goodNameVar(var.Name))	
                      else:
                          if primitive:
                              self.hasArray = True
                              self.code +="	public void %s(ArrayList<%s> %s){\n" % ("set"+first.upper()+goodNameVar(var.Name[1:]),firstTypename.upper()+typename[1:],goodNameVar(var.Name))
                          else:
                              self.hasArray = True
                              self.code +="	public void %s(ArrayList<? extends %sValue> %s){\n" % ("set"+first.upper()+goodNameVar(var.Name[1:]),goodName(typename[:-2]),goodNameVar(var.Name))
                  else:
                      # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                      # also we test if the file is not in the array of diffFiles (files that are treated different)
                      if "count" not in var.Name  or sourcefilename in diffFiles:
                          if primitive:
                              if member.typename == "uint8_t":
                                  typename = 'char'
                              self.code +="	public void %s(%s %s){\n" % ("set"+first.upper()+goodNameVar(var.Name[1:]),typename,goodNameVar(var.Name))
                          else:
                              self.code +="	public void %s(%sValue %s){\n" % ("set"+first.upper()+goodNameVar(var.Name[1:]),goodName(typename[:-2]),goodNameVar(var.Name))
                  # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                  # also we test if the file is not in the array of diffFiles (files that are treated different)
                  if "count" not in var.Name  or sourcefilename in diffFiles:
                      self.code +="		this.%s = %s;\n" % (goodNameVar(var.Name),goodNameVar(var.Name))
                      self.code +="	}\n\n"
                
          return (self.code,self.hasArray, self.hasBaos)
    			  
      def genBufferSize(self,datatype, sourcefilename):
          self.hasArray = False
          self.hasBaos = False
          self.code = ""
          
          self.code +="	public int getBufferLength(){\n"
          self.code +="		int aux=0;\n"
          i = 0
          for member in datatype.members:			
              for var in member.variables:
                  # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                  # also we test if the file is not in the array of diffFiles (files that are treated different)
                  if "count" not in var.Name  or sourcefilename in diffFiles:
                      # Do some name mangling for common types
                      # Depending on the primitive data type the size varies
                      if member.typename == 'long long':
                          typename = 'long'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 8*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
                                  self.code +="		aux = aux + 8*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
                              self.code +="		aux = aux + 8;\n"
                      elif member.typename == 'int64_t':
                          typename = 'long'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 8*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
                                  self.code +="		aux = aux + 8*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
                              self.code +="		aux = aux + 8;\n"
                      elif member.typename == 'uint64_t':
                          typename = 'long'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 8*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
                                  self.code +="		aux = aux + 8*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
                              self.code +="		aux = aux + 8;\n"
                      elif member.typename == 'int32_t':
                          typename = 'int'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 4*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
                                  self.code +="		aux = aux + 4*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
                              self.code +="		aux = aux + 4;\n"
                      elif member.typename == 'uint32_t':
                          typename = 'int'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 4*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
                                  self.code +="		aux = aux + 4*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
                              self.code +="		aux = aux + 4;\n"
                      elif member.typename == 'int16_t':
                          typename = 'short'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 4*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
    						      self.code +="		aux = aux + 4*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
    			              self.code +="		aux = aux + 4;\n"
                      elif member.typename == 'uint16_t':
                          typename = 'short'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 4*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
    						      self.code +="		aux = aux + 4*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
    					      self.code +="		aux = aux + 4;\n"
                      elif member.typename == 'int8_t' or member.typename == 'char':
                          typename = 'char'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 4*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
                                  self.code +="		aux = aux + 4*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
    						  self.code +="		aux = aux + 4;\n"
                      elif member.typename == 'uint8_t':
                          typename = 'char'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 4*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
    						      self.code +="		aux = aux + 4*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
                              self.code +="		aux = aux + 4;\n"
                      elif member.typename == 'bool_t':
                          typename = 'boolean'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 4*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
    					   	       self.code +="		aux = aux + 4*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
                             self.code +="		aux = aux + 4;\n"
                      elif member.typename == 'double':
                          typename = 'double'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 8*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
                                  self.code +="		aux = aux + 8*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
                              self.code +="		aux = aux + 8;\n"
                      elif member.typename == "float":
                          typename = 'float'
                          if var.array:
                              if goodNameVar(var.Name) in strings:
                                  self.code +="        aux = aux + 4*%s().length();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                              else:
                                  self.code +="		aux = aux + 4*%s().size();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                          else:
                             self.code +="		aux = aux + 4;\n"
                      else:
                          typename = member.typename
                          # If the object is an array we have to call to the getBufferLength() method of the XDRObject that forms the array an multiply by the array length
                          if var.array:
                               self.code +="        if( %s().size() == 0)\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                               self.code +="            return 0;\n"
                               self.code +="        XDRObject obj%d = (XDRObject)%s().get(0);\n" % (i,"get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                               self.code +="        int len%d = obj%d.getBufferLength();\n" % (i,i)
                               self.code +="        aux = aux + len%d*%s().size();\n" % (i,"get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
#                              self.code +="		Object obj%d = %s().get(0);\n" % (i,"get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
#                              self.code +="		int len%d = 0;\n" % (i)
#                              self.code +="		if (obj%d instanceof Integer){\n" % (i)
#                              self.code +="			len%d = new XDRInt((Integer)obj%d).getBufferLength();\n"  % (i,i)
#                              self.code +="		}\n"
#                              self.code +="		if (obj%d instanceof Byte){\n"  % (i)
#                              self.code +="			len%d = new XDRByte((Byte)obj%d).getBufferLength();\n"  % (i,i)
#                              self.code +="		}\n"
#                              self.code +="		if (obj%d instanceof Short){\n"  % (i)
#                              self.code +="			len%d = new XDRShort((Short)obj%d).getBufferLength();\n"  % (i,i)
#                              self.code +="		}\n"
#                              self.code +="		if (obj%d instanceof Long){\n"  % (i)
#                              self.code +="			len%d = new XDRLong((Long)obj%d).getBufferLength();\n"  % (i,i)
#                              self.code +="		}\n"
#                              self.code +="		if (obj%d instanceof Float){\n"  % (i)
#                              self.code +="			len%d = new XDRFloat((Float)obj%d).getBufferLength();\n"  % (i,i)
#                              self.code +="		}\n"
#                              self.code +="		if (obj%d instanceof Double){\n"  % (i)
#                              self.code +="			len%d = new XDRDouble((Double)obj%d).getBufferLength();\n"  % (i,i)
#                              self.code +="		}\n"
#                              self.code +="		if (obj%d instanceof String){\n"  % (i)
#                              self.code +="			len%d = new XDRString((String)obj%d).getBufferLength();\n"  % (i,i)
#                              self.code +="		}\n"
#                              self.code +="		if (obj%d instanceof Boolean){\n"  % (i)
#                              self.code +="			len%d = new XDRBoolean((Boolean)obj%d).getBufferLength();\n"  % (i,i)
#                              self.code +="		}\n"
#                              self.code +="		aux = aux + len%d*%s().size();\n" % (i,"get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                               i = i + 1
                          else:
                              # If the object is not an XDRArray but is not a primitive data type, we call the getBufferLength() method for that XDRObject
                              self.code +="		aux = aux + ((%s)%s()).getBufferLength();\n" % (goodName(typename[:-2]),"get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
    					
    	  self.code +="		return aux;\n"
    	  self.code +="	}\n"
          
          return (self.code,self.hasArray, self.hasBaos)
    			  
      
      # generate method toXDR()
      def genTo(self,datatype, sourcefilename):
              self.hasArray = False
              self.hasBaos = True
              self.code = ""
          
              # if the object has some variables, we have to throw XDRException and IOException
              if existVariables(datatype):
    	  
                  self.code +="	public byte[] toXDR() throws XDRException, IOException {\n"
                  
              # if the object has no variables, we don't have to throw IOException or XDRException
              else:
                  
                  self.code +="	public byte[] toXDR(){\n"
                  
              self.code +="		ByteArrayOutputStream baos = new ByteArrayOutputStream();\n"
    
              # For each variables of the objects we call the encode method of the XDREncodingHelper
              for member in datatype.members:
                      for var in member.variables:
                              if var.array:
                                    if goodNameVar(var.Name) in strings:
                                        self.code +="        baos.write(XDREncodingHelper.encode(%s().length()));\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                                    else:
                                        self.code +="        baos.write(XDREncodingHelper.encode(%s().size()));\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                                    self.code +="        baos.write(XDREncodingHelper.encode(%s()));\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
                                     
                              else:
                                        
                                    # "count" variables are not added to java objects because they number of elements of an array, and this can be controlled with the arraylist class in java
                                    # also we test if the file is not in the array of diffFiles (files that are treated different)
                                    if "count" not in var.Name or sourcefilename in diffFiles:
                                            self.code +="        baos.write(XDREncodingHelper.encode(%s()));\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:])
            
              self.code +="		return baos.toByteArray();\n"
              self.code +="	}\n\n"
              return (self.code,self.hasArray, self.hasBaos)
              
              
      # generate method getEnclosedValue()
      def gengetEnclosedValue(self):
          self.hasArray = False
          self.hasBaos = False
          self.code = ""
          
          self.code += "    public Object getEnclosedValue(){\n"
          self.code += "        return this;\n"
          self.code += "    }\n\n"
          
          return (self.code, self.hasArray, self.hasBaos)
    		  
      # generate method fromXDR()
      def genFrom(self,datatype, sourcefilename):
              self.hasArray = False
              self.hasBaos = False
              self.code = ""
    	  
              self.code +="	public void fromXDR(byte[] buffer, int idx, int len) throws XDRException{\n"
                  
              for member in datatype.members:
                      for var in member.variables:
                              Primitive = True #Primitive java types
                              # Do some name mangling for common types
                              if member.typename == 'long long':
                                    typename = 'long'
                              elif member.typename == 'int64_t':
                                    typename = 'long'
                              elif member.typename == 'uint64_t':
                                    typename = 'long'
                              elif member.typename == 'int32_t':
                                    typename = 'int'
                              elif member.typename == 'uint32_t':
                                    typename = 'int'
                              elif member.typename == 'int16_t':
                                    typename = 'short'
                              elif member.typename == 'uint16_t':
                                    typename = 'short'
                              elif member.typename == 'int8_t' or member.typename == 'char':
                                    typename = 'char'
                              elif member.typename == 'uint8_t':
                                    typename = 'char'
                              elif member.typename == 'bool_t':
                                    typename = 'boolean'
                              elif member.typename == 'double':
                                    typename = 'double'
                              elif member.typename == 'float':
                                    typename = 'float'
                              elif member.typename == 'int':
                                    typename = 'int'
                              elif member.typename == 'long':
                                    typename = 'long'
                              elif member.typename == 'boolean':
                                    typename = 'boolean'
                              elif member.typename == 'short':
                                    typename = 'short'
                              else:
                                    # rely on a previous declaration of an xdr_ proc for this type
                                    typename = member.typename
                                    Primitive = False
                            
                              if var.array:
                                    if Primitive:
                                            if goodNameVar(var.Name) in strings:
                                                self.code +="        XDRString %s = new XDRString(buffer, idx, len);\n" % (goodNameVar(var.Name))
                                                self.code +="        %s(%s.getValue());\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:], goodNameVar(var.Name))
                                                self.code +="        idx += %s.getBufferLength();\n" % (goodNameVar(var.Name))
                                            else:
                                                self.code +="        XDRArray<XDR%s> %s = new XDRArray<XDR%s>(buffer, idx, len, null,XDR%s.class);\n" % (typename[0].upper()+typename[1:], goodNameVar(var.Name), typename[0].upper()+typename[1:],typename[0].upper()+typename[1:])
                                                self.code +="        %s(%s);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:], goodNameVar(var.Name))
                                                self.code +="        idx += %s.getBufferLength();\n" % (goodNameVar(var.Name))
                                            #if typename == 'char':
                                                #self.code +="             %s.reset();\n" % ("get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:]))
                                                #self.code +="        ArrayList<XDRObject> tmp%d = new XDRArray(buffer, idx, len, new XDR%s(), %s().size()).getValue();\n" % (i,typename[0].upper()+typename[1:],"get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:]))
                                                #self.code +="             Iterator<XDRObject> it%d = tmp%d.iterator();\n" % (i,i));
                                                #self.code +="             while(it%d.hasNext()) %s.write(((%s)it%d.next()).getValue());\n" % (i,goodNameVar(var.Name),"XDR"+typename[0].upper()+typename[1:],i));
                                                #self.code +="        %s(tmp%d);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:],i))
                                                #i = i+1
                                            #else:
                                                #self.code +="             %s.clear();\n" % (goodNameVar(var.Name)))
                                                #self.code +="        ArrayList<XDRObject> tmp%d = new XDRArray(buffer, idx, len, new XDR%s(), %s().size()).getValue();\n" % (i,typename[0].upper()+typename[1:],"get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:]))
                                                #self.code +="             Iterator<XDRObject> it%d = tmp%d.iterator();\n" % (i,i));
                                                #self.code +="             while(it%d.hasNext()) %s.add(((%s)it%d.next()).getValue());\n" % (i,goodNameVar(var.Name),"XDR"+typename[0].upper()+typename[1:],i));
                                                #self.code +="        %s(tmp%d);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:],i))
                                                #i = i+1
                                            #self.code +="		        %s = new XDRArray(buffer,idx,len,%s).getValue();\n" % ("Character", var.Name, "Character"))	
                                    else:
                                            self.code +="        XDRArray<%s> %s = new XDRArray<%s>(buffer, idx, len, null, %s.class);\n" % (goodName(typename[:-2]), goodNameVar(var.Name), goodName(typename[:-2]),goodName(typename[:-2]))
                                            self.code +="        %s(%s);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:],goodNameVar(var.Name))
                                            self.code +="        idx += %s.getBufferLength();\n" % (goodNameVar(var.Name))
                                            #self.code +="             %s.clear();\n" % (goodNameVar(var.Name)))
                                            #self.code +="        ArrayList<XDRObject> tmp%d = new XDRArray(buffer, idx, len, new %s(), %s().size()).getValue();\n" % (i,goodName(typename[:-2]),"get"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:]))
                                            #self.code +="             Iterator<XDRObject> it%i = tmp%d.iterator();\n" %(i,i));
                                            #self.code +="             while(it%i.hasNext()) %s.add((%s)it%i.next());\n" % (i,goodNameVar(var.Name),goodName(typename[:-2]),i));
                                            #self.code +="        %s(tmp%d);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:],i))
                                            #i = i+1
                                            #self.code +="		        %s = new XDRArray(buffer,idx,len,%s).getValue();\n" % (var.Name, typename))	
                              else:
                                    if "count" in var.Name and sourcefilename not in diffFiles:
                                            self.code +="        XDRInt %s = new XDRInt(buffer, idx, len);\n" % (goodNameVar(var.Name))
                                            self.code +="        idx += %s.getBufferLength();\n" % (goodNameVar(var.Name))
                                    # "count" variables are not added to java objects because they number the elements of an array, and this can be controlled with the arraylist class in java
                                    # also we test if the file is not in the array of diffFiles (files that are treated different)
                                    if "count" not in var.Name  or sourcefilename in diffFiles:
                                            if Primitive:
                                                    self.code +="        %s %s = new %s(buffer, idx, len);\n" % ("XDR"+typename[0].upper()+typename[1:], goodNameVar(var.Name), "XDR"+typename[0].upper()+typename[1:]) 
                                                    self.code +="        %s(%s.getValue());\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:], goodNameVar(var.Name))
                                                    self.code +="        idx += %s.getBufferLength();\n" % (goodNameVar(var.Name))
                    
                                            else:
                                                    self.code +="        %s %s = new %s(buffer, idx, len);\n" % (goodName(typename[:-2]), goodNameVar(var.Name), goodName(typename[:-2]))
                                                    self.code +="        %s(%s);\n" % ("set"+goodNameVar(var.Name)[0].upper()+goodNameVar(var.Name)[1:], goodNameVar(var.Name))
                                                    self.code +="        idx += %s.getBufferLength();\n" % (goodNameVar(var.Name))
                                                    
                                                                 
              self.code +="	}\n\n"
              return (self.code,self.hasArray, self.hasBaos)
              
              
# Method to test if the object has variables
def existVariables(datatype):
    
    primitive = False
    for member in datatype.members:
        if len(member.variables) > 0:
            primitive = True
            
    return primitive
            
              

# Method to test if there are only primitive variables or no
def onlyNoPrimitive(datatype):
    
    primitive = False
    
    for member in datatype.members:
		  for var in member.variables:
			  # Do some name mangling for common types
			  if member.typename == 'long long':
				primitive = True;
			  elif member.typename == 'int64_t':
				primitive = True;
			  elif member.typename == 'uint64_t':
				primitive = True;
			  elif member.typename == 'int32_t':
				primitive = True;
			  elif member.typename == 'uint32_t':
				primitive = True;
			  elif member.typename == 'int16_t':
				primitive = True;
			  elif member.typename == 'uint16_t':
				primitive = True;
			  elif member.typename == 'int8_t' or member.typename == 'char':
				primitive = True;
			  elif member.typename == 'uint8_t':
				primitive = True;
			  elif member.typename == 'bool_t':
				primitive = True;
			  elif member.typename == 'double':
				primitive = True;
			  elif member.typename == 'float':
				primitive = True;
                          elif member.typename == 'int':
                                primitive = True;
                          elif member.typename == 'long':
                                primitive = True;
                          elif member.typename == 'boolean':
                                primitive = True;
                          elif member.typename == 'short':
                                primitive = True;
                                
    return primitive
              
              
# Method used to change the name to a well formed java version          
def goodName(name):
    i = 0
    res = ''
    cambiar = False
    for c in name:
        if i == 0:
            res = res + c.upper()
            i = i + 1
        elif cambiar:
            res = res + c.upper()
            cambiar = False
        elif c != '_':
            res = res + c
        elif c == '_':
            cambiar = True
            
    return res
            
# Method used to change the variables name to a well formed java version
def goodNameVar(name):
    res = ''
    cambiar = False
    for c in name:
        if cambiar:
            res = res + c.upper()
            cambiar = False
        elif c != '_':
            res = res + c
        elif c == '_':
            cambiar = True
            
    return res
  
	

if __name__ == '__main__':

  if len(sys.argv) < 2:
    print USAGE
    sys.exit(-1)

  distro = 0

  idx = 1
  if sys.argv[1] == '-distro':
    if len(sys.argv) < 3:
      print USAGE
      sys.exit(-1)
    distro = 1
    idx += 1

  #infilenames = [sys.argv[idx],]
  infilenames = []
  directory = 0
  
  for i in xrange(1,len(sys.argv)):
      if directory != 1:
          if sys.argv[i] != '-D':
              if sys.argv[i] != '-distro':
                  infilenames.append(sys.argv[i])
          else:
              directory = 1
      else:
          directory = 0

  # Read in the entire file
  instream = ""
  for f in infilenames:
    infile = open(f, 'r')
    instream += infile.read()
    infile.close()
        
  # strip C++-style comments
  pattern = re.compile('//.*')
  instream = pattern.sub('', instream)

  # strip C-style comments
  pattern = re.compile('/\*.*?\*/', re.MULTILINE | re.DOTALL)
  instream = pattern.sub('', instream)

  # strip blank lines
  pattern = re.compile('^\s*?\n', re.MULTILINE)
  instream = pattern.sub('', instream)

  # find structs
  pattern = re.compile('typedef\s+struct\s+player_\w+[^}]+\}[^;]+',
                   re.MULTILINE)
  structs = pattern.findall(instream)

    
  #print 'Found ' + `len(structs)` + ' struct(s)'
  
  # files treated different
  diffFiles = ["PlayerDioData.java", "PlayerLocalizeData.java"]
  # Variable used for the serialversionUID
  serial = "1"

  for s in structs:
      current = DataType(s)
      sourcefilename = goodName(current.prefix) + ".java"
      if dir:
          sourcefile = open(DIR + VALUE_PATH + sourcefilename[:-5] + 'Value.java', 'w+')
      else:
          sourcefile = open("./" + VALUE_PATH + sourcefilename[:-5] + 'Value.java', 'w+')
      #sourcefile = open('../player/generated/value/' + sourcefilename[:-5] + 'Value.java', 'w+')
      
      sourcefile.write(LICENSE)
      
      hasArray = False
      hasBaos = False
      code = ""
      
      gen = MethodGenerator(sourcefile)
      
      # Generate value objects
      
      # Call each of the methods that are going to generate the different methods of the structure files.
      # After calling each method test if it uses ByteArrayOutputStream or ArrayList, so we can include the suitable import at the beginning.
      res = gen.genJava(current, sourcefilename)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      res = gen.genConstructor(current, sourcefilename)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      res = gen.genConstructorCopy(current, sourcefilename)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      res = gen.genSetterGetter(current, sourcefilename)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]

      #Replace imports
      if hasArray:
          code = code.replace("ARRAYLIST", "import java.util.ArrayList;\nimport java.util.List;\n")
      else:
          code = code.replace("ARRAYLIST", "\n")
      if hasBaos:
          code = code.replace("BAOS", "import java.io.ByteArrayOutputStream;\n")
      else:
          code = code.replace("BAOS", "\n")
          
      # Write "code" string to the suitable file
      sourcefile.write(code)

      sourcefile.write("}\n")
      
      sourcefile.close()
      
      code = ""
      hasArray = False
      hasBaos = False
      if dir:
          sourcefile = open(DIR + XDR_PATH + sourcefilename, 'w+')
      else:
          sourcefile = open("./" + XDR_PATH + sourcefilename, 'w+')
      #sourcefile = open('../player/generated/xdr/' + sourcefilename, 'w+')
      
      sourcefile.write(LICENSE)
      
      gen = MethodGenerator(sourcefile)
      
      # Generate xdr objects
      
      # Call each of the methods that are going to generate the different methods of the structure files.
      # After calling each method test if it uses ByteArrayOutputStream or ArrayList, so we can include the suitable import at the beginning.
      res = gen.genHeadings(current)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      res = gen.genXDRConstructor(current, sourcefilename)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      res = gen.genConstructorWithParameters(current, sourcefilename)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      res = gen.gengetEnclosedValue()
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      res = gen.genBufferSize(current, sourcefilename)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      res = gen.genTo(current, sourcefilename)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      res = gen.genFrom(current, sourcefilename)
      code += res[0]
      hasArray = hasArray or res[1]
      hasBaos = hasBaos or res[2]
      
      #Replace imports
      if hasArray:
          code = code.replace("ARRAYLIST", "import java.util.ArrayList;\nimport java.util.List;\n")
      else:
          code = code.replace("ARRAYLIST", "\n")
      if hasBaos:
          code = code.replace("BAOS", "import java.io.ByteArrayOutputStream;\n")
      else:
          code = code.replace("BAOS", "\n")
          
      #Write "code" string to the suitable file
      sourcefile.write(code)
      sourcefile.write("}\n")
	  
      sourcefile.close()
	  
  
